# Dimensionality Reduction — FitzHugh–Nagumo Simulation

This interactive mirrors the FitzHugh–Nagumo spiking neuron simulation described in `01_dimensionality-reduction.md`. It integrates the same two-dimensional ODE with a smoothed random input current and shows both the phase space `(V, R)` and voltage over time `V(t)`.

- Model: `dV/dt = 10 (V − V^3 − 2R + I(t))`, `dR/dt = 0.1 (−R + 1.25V + 1.5)`
- Input: `I(t)` is generated by smoothing uniform noise, plus per-trial smoothed noise, matching the notes.
- Plots: left is phase space `(V, R)`; right is `V` versus time.

<div style="display:flex; gap:16px; flex-wrap:wrap">
  <svg id="fhng-phase" width="520" height="380" viewBox="0 0 520 380" style="border:1px solid #ccc; background:#fff"></svg>
  <svg id="fhng-vt"    width="520" height="380" viewBox="0 0 520 380" style="border:1px solid #ccc; background:#fff"></svg>
  <div style="font:12px/1.4 system-ui, sans-serif; color:#555">Phase space (left): V vs R. Voltage trace (right): V(t). Reload to restart.</div>
  <div style="font:12px/1.4 system-ui, sans-serif; color:#555">Parameters: N=12 trials, T=1000, dt=0.5. Currents mimic the R notes (base + smoothed noise).</div>
</div>

```js browser
// FitzHugh–Nagumo simulation to match 01_dimensionality-reduction.md
// Animated step-by-step at dt=0.05 with a small delay per step.
// Equations (as used in the R code):
//   dV/dt = 10*( V - V^3 - 2*R + I(t) )
//   dR/dt = 0.1*( -R + 1.25*V + 1.5 )
(function runFHNG() {
  const svgPhase = document.querySelector('#fhng-phase');
  const svgVT    = document.querySelector('#fhng-vt');
  if (!svgPhase || !svgVT) return;
  if (svgPhase.dataset.simRunning === 'yes') return; // avoid double start
  svgPhase.dataset.simRunning = 'yes';
  svgVT.dataset.simRunning = 'yes';

  // Helpers
  const Wp = svgPhase.viewBox?.baseVal?.width  || svgPhase.clientWidth  || 520;
  const Hp = svgPhase.viewBox?.baseVal?.height || svgPhase.clientHeight || 380;
  const Wt = svgVT.viewBox?.baseVal?.width  || svgVT.clientWidth  || 520;
  const Ht = svgVT.viewBox?.baseVal?.height || svgVT.clientHeight || 380;
  function elt(name){ return document.createElementNS('http://www.w3.org/2000/svg', name); }

  // Remove existing children
  while (svgPhase.firstChild) svgPhase.removeChild(svgPhase.firstChild);
  while (svgVT.firstChild) svgVT.removeChild(svgVT.firstChild);

  // Simulation parameters
  const Ntrials = 12;     // number of trajectories
  const dt = 0.05;        // integration time step (requested)
  const T = 200;          // total time horizon (shortened for animation)
  const steps = Math.floor(T/dt);
  const delayMs = 8;      // artificial delay so drawing is visible

  // Build smoothed base stimulus, then per-trial smoothed noise
  const Nstim = 1000;
  function smooth1(a){
    const n = a.length; const out = new Array(n);
    for (let i=0;i<n;i++){
      const l = a[(i-1+n)%n], c=a[i], r=a[(i+1)%n];
      out[i] = (l + c + r)/3;
    }
    return out;
  }
  function smooth(a, times){ let out = a.slice(); for(let k=0;k<times;k++) out = smooth1(out); return out; }
  function randArr(n, min=0, max=1){ const a=new Array(n); for(let i=0;i<n;i++) a[i]=min+Math.random()*(max-min); return a; }
  function randArrSym(n, amp=1){ const a=new Array(n); for(let i=0;i<n;i++) a[i] = (Math.random()*2-1)*amp; return a; }
  const baseStim = smooth(randArr(Nstim, 0, 1), 50); // similar to R: runif + smooth

  function makeCurrent(base, noiseAmp=0.3){
    const noise = smooth(randArrSym(base.length, 1), 50).map(v => v*noiseAmp);
    const arr = base.map((b, i) => 0.27 + b*2.5 + noise[i]);
    // Continuous interpolation over [0, T]
    return function I(t){
      const nt = Math.max(0, Math.min(base.length-1, (base.length-1)*(t/T)));
      const i0 = Math.floor(nt), i1 = Math.min(base.length-1, i0+1);
      const w = nt - i0; return arr[i0]*(1-w) + arr[i1]*w;
    };
  }

  // Dynamics
  function fFactory(I){
    return function f(t, y){
      const V = y[0], R = y[1];
      const dV = 10*( V - V*V*V - 2*R + I(t) );
      const dR = 0.1*( -R + 1.25*V + 1.5 );
      return [dV, dR];
    };
  }
  function add(a,b){ return [a[0]+b[0], a[1]+b[1]]; }
  function sc(a,s){ return [a[0]*s, a[1]*s]; }
  function rk4Step(f, t, y, h){
    const k1 = f(t, y);
    const k2 = f(t + h/2, add(y, sc(k1, h/2)));
    const k3 = f(t + h/2, add(y, sc(k2, h/2)));
    const k4 = f(t + h,   add(y, sc(k3, h  )));
    const inc = sc(add(add(k1, sc(add(k2,k3), 2)), k4), h/6);
    return add(y, inc);
  }

  // Trials state (incremental integration)
  const trials = [];
  const ic = [-1.07386247, 0.1642691]; // initial condition from notes
  for (let i=0;i<Ntrials;i++){
    const I = makeCurrent(baseStim, 0.3);
    const f = fFactory(I);
    const color = `hsl(${Math.floor((i/Ntrials)*300)}, 70%, 45%)`;
    const y0 = [ic[0] + (Math.random()*0.1-0.05), ic[1] + (Math.random()*0.1-0.05)];
    trials.push({ color, f, t: 0, y: y0, pointsP: [], pointsT: [] });
  }

  // Static world extents for stability during animation
  const worldP = { xMin: -2.5, xMax: 2.5, yMin: -1.5, yMax: 2.5 };
  const x2sxP = x => ( (x - worldP.xMin) / (worldP.xMax - worldP.xMin) ) * Wp;
  const y2syP = y => Hp - ( (y - worldP.yMin) / (worldP.yMax - worldP.yMin) ) * Hp;

  const worldT = { xMin: 0, xMax: T, yMin: -2.5, yMax: 2.5 };
  const x2sxT = x => ( (x - worldT.xMin) / (worldT.xMax - worldT.xMin) ) * Wt;
  const y2syT = y => Ht - ( (y - worldT.yMin) / (worldT.yMax - worldT.yMin) ) * Ht;

  // Axes for both plots
  function drawAxes(svg, W, H, x0, y0, xScale, yScale){
    const g = elt('g'); svg.appendChild(g);
    const axX = elt('line');
    axX.setAttribute('x1', '0'); axX.setAttribute('x2', String(W));
    axX.setAttribute('y1', String(yScale(y0))); axX.setAttribute('y2', String(yScale(y0)));
    axX.setAttribute('stroke', '#eee'); axX.setAttribute('stroke-width', '1'); g.appendChild(axX);
    const axY = elt('line');
    axY.setAttribute('y1', '0'); axY.setAttribute('y2', String(H));
    axY.setAttribute('x1', String(xScale(x0))); axY.setAttribute('x2', String(xScale(x0)));
    axY.setAttribute('stroke', '#eee'); axY.setAttribute('stroke-width', '1'); g.appendChild(axY);
    return g;
  }
  drawAxes(svgPhase, Wp, Hp, 0, 0, x2sxP, y2syP); // V=0, R=0
  drawAxes(svgVT,    Wt, Ht, 0, 0, x2sxT, y2syT);  // t=0, V=0

  // Initialize polylines and first points
  for (const tr of trials){
    tr.plP = elt('polyline'); tr.plP.setAttribute('fill','none'); tr.plP.setAttribute('stroke', tr.color); tr.plP.setAttribute('stroke-width','1.2');
    tr.plT = elt('polyline'); tr.plT.setAttribute('fill','none'); tr.plT.setAttribute('stroke', tr.color); tr.plT.setAttribute('stroke-width','1.2'); tr.plT.setAttribute('opacity','0.9');
    tr.pointsP.push(`${x2sxP(tr.y[0])},${y2syP(tr.y[1])}`);
    tr.pointsT.push(`${x2sxT(0)},${y2syT(tr.y[0])}`);
    tr.plP.setAttribute('points', tr.pointsP.join(' ')); svgPhase.appendChild(tr.plP);
    tr.plT.setAttribute('points', tr.pointsT.join(' ')); svgVT.appendChild(tr.plT);
  }

  // Step-by-step animation with controlled delay
  let step = 0; let stopped = false;
  function tick(){
    if (stopped || step >= steps) return;
    step++;
    for (const tr of trials){
      tr.y = rk4Step(tr.f, tr.t, tr.y, dt);
      tr.t += dt;
      tr.pointsP.push(`${x2sxP(tr.y[0])},${y2syP(tr.y[1])}`);
      tr.pointsT.push(`${x2sxT(tr.t)},${y2syT(tr.y[0])}`);
    }
    for (const tr of trials){ tr.plP.setAttribute('points', tr.pointsP.join(' ')); tr.plT.setAttribute('points', tr.pointsT.join(' ')); }
    setTimeout(tick, delayMs); // artificial delay so growth is visible
  }
  setTimeout(tick, delayMs);
})();
```

Notes:

- The parameters and input generation follow the R code in the notes (smoothed `runif` plus smoothed noise per trial; same initial condition, same time horizon).
- The left panel approximates the phase portrait with multiple trials; the right panel overlays their voltage traces over time.
